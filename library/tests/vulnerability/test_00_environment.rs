whitebeam_test!("linux", vulnerability_00_LD_BIND_NOW {
    // Ensure that specifying LD_BIND_NOW causes programs to abort
    let baseline_true_exit = std::process::Command::new("/usr/bin/true").status().expect("true command failed to start");
    assert!(baseline_true_exit.success());
    let bind_now_true_exit = std::process::Command::new("/usr/bin/true")
                                                   .stderr(std::process::Stdio::null())
                                                   .env("LD_BIND_NOW", "1").status().expect("true command failed to start");
    assert!(!(bind_now_true_exit.success()));
});

whitebeam_test!("linux", vulnerability_01_LD_PRELOAD_LD_AUDIT {
    // Ensure that Prevention blocks non-whitelisted LD_PRELOAD and LD_AUDIT libraries specified by environment variables
    // Ref: https://github.com/WhiteBeamSec/WhiteBeam/security/advisories/GHSA-mm3f-f5hg-p2hv
    let libcap: &str = &format!("/lib/{}-linux-gnu/libcap.so.2", std::env::consts::ARCH);
    crate::common::toggle_prevention(true);
    let whoami_output: *mut libc::FILE = unsafe { libc::popen((&format!("LD_PRELOAD={} LD_AUDIT={} /usr/bin/whoami 2>&1\0", libcap, libcap)).as_ptr() as *const libc::c_char, "r\0".as_ptr() as *const libc::c_char) };
    let mut whoami_output_str = String::new();
    unsafe {
        let mut buffer = vec![0; 1024];
        while libc::fread(buffer.as_mut_ptr().cast(), 1, 1024, whoami_output) > 0 {
            whoami_output_str.push_str(std::str::from_utf8(&buffer).expect("whoami output was not valid UTF-8"));
        }
    }
    crate::common::toggle_prevention(false);
    assert!(whoami_output_str.contains(&format!("ERROR: ld.so: object '{}' cannot be loaded as audit interface", libcap)));
    assert!(whoami_output_str.contains(&format!("ERROR: ld.so: object '{}' from LD_PRELOAD cannot be preloaded", libcap)));
});

whitebeam_test!("linux", vulnerability_02_LD_LIBRARY_PATH {
    // Ensure that LD_LIBRARY_PATH does not interfere with the load order of libwhitebeam.so
    std::fs::copy("/bin/bash", "/tmp/libc.so.6").expect("WhiteBeam: Failed to copy test libc.so.6");
    crate::common::toggle_prevention(true);
    let whoami_output: *mut libc::FILE = unsafe { libc::popen("LD_LIBRARY_PATH=/tmp/ LD_PRELOAD=libc.so.6 /usr/bin/whoami 2>&1\0".as_ptr() as *const libc::c_char, "r\0".as_ptr() as *const libc::c_char) };
    let mut whoami_output_str = String::new();
    unsafe {
        let mut buffer = vec![0; 1024];
        while libc::fread(buffer.as_mut_ptr().cast(), 1, 1024, whoami_output) > 0 {
            whoami_output_str.push_str(std::str::from_utf8(&buffer).expect("whoami output was not valid UTF-8"));
        }
    }
    crate::common::toggle_prevention(false);
    std::fs::remove_file("/tmp/libc.so.6").expect("WhiteBeam: Failed to delete test libc.so.6");
    assert!(!(whoami_output_str.contains("cannot dynamically load position-independent executable")));
});